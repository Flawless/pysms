#!/usr/bin/env python
import serial
import time
import socketserver
import queue
import threading
import logging
import sys
import datetime
import signal
import ast
import traceback
import binascii
import struct
import math
#sys.path.append('/home/flawless/projects/work/fletcontrol/pySMS/lib/python/')
import fl_models
# SETTINGS
tcp_serv_addr=('', 25111)
serial_ports=['/dev/ttyACM1']#, ('/dev/ttyACM1','19200'), ('/dev/ttyACM2','19200')]
msg_ok=b'OK'
msg_error=b'ERROR'
period=5
timeout=120
# INIT
STEP = 1.0/2**32
logging.basicConfig(format = '%(levelname)-8s %(process)s %(thread)s: [%(asctime)s] %(message)s', level = logging.DEBUG, filename = '/var/log/pysms.log')
state='idle'
timestamp=time.time()
send_sms_queue=queue.Queue()
recieved_sms_queue=queue.Queue()
tcp_serv_thread=threading.Thread()
devices=[]
def from_our_format2float(array):
    i = array[:2]
    f = array[2:]
    i = struct.unpack('h', i)
    f = struct.unpack('I', f)
    return i + math.copysign(f*STEP,i)
def write_hex(bstr):  #hexlify
    try:
        binascii.unhexlify(bstr)
        return bstr
    except binascii.Error:
        return binascii.hexlify(bstr)
def write_hex2(bstr):   #unhexlify
    try:
        binascii.hexlify(bstr)
        return bstr
    except binascii.Error:
        return binascii.unhexlify(bstr)
        
def manage_devices():
    while not recieved_sms_queue.empty():
        sms=recieved_sms_queue.get()
        try:
            thread=threading.Thread(target=sms.to_base)
            logging.debug('writing %s to base, good luck...'%sms)
            thread.start()
        except Exception as e:
            for frame in traceback.extract_tb(sys.exc_info()[2]):
                fname,lineno,fn,text = frame
                print("Error in %s on line %d" % (fname, lineno))
            logging.error('%s %s'%(sys.exc_info()[0], sys.exc_info()[1]))
            recieved_sms_queue.put(sms)
    for dev in devices:
        if dev.status=='crashed' or dev.status=='running' and time.time()-dev.timestamp>300:
            logging.debug('%s from %s'%(dev.status,time.time()-dev.timestamp))
            logging.info('Trying to re-initiate device %s'%dev)
            if not dev.sms==None:
                send_sms_queue.put(dev.sms)
                dev.sms=None
            thread=threading.Thread(target=dev.initiate)
            thread.start()
            dev.set_status('running')
        elif dev.status=='sleep':
            if not send_sms_queue.empty():
                logging.debug('sending sms')
                sms=send_sms_queue.get(block=False)
                dev.set_sms(sms)
                logging.debug('sending sms: %s'%sms)
                thread=threading.Thread(target=dev.send_sms)
                thread.start()
                dev.set_status('running')
            elif time.time()-dev.check_timestamp>60:
                logging.debug('reading sms')
                thread=threading.Thread(target=dev.read_sms)
                thread.start()
                dev.set_status('running')
            
def myexcepthook(exctype, value, traceback):
    if exctype == KeyboardInterrupt:
        logging.info('Terminated by user')
        global state
        state='shutdown'
    else:
        sys.__excepthook__(exctype, value, traceback)
sys.excepthook = myexcepthook
def signal_term_handler(signal, frame):
    global state
    logging.info('recieved sigterm')
    state='shutdown'
signal.signal(signal.SIGTERM, signal_term_handler)
class Device():
    def __init__(self, serial_port, status='crashed'):
        self.serial_port = serial_port
        self.status  = status
        self.thread = ''
        self.sms    = None
        self.check_timestamp = time.time()-1000
        self.sm = []
    def __repr__(self):
        return self.serial_port.port
    def set_sms(self, sms):
        self.sms=sms
    def set_status(self, status):
        logging.debug('device: %s status: %s'%(self,status))
        self.timestamp=time.time()
        self.status=status
    def initiate(self):
        try:
            logging.info('serial..')
            self.serial_port.close()
            self.serial_port.open()
            logging.info('OK')
            # logging.info('power..')
            # if not check_power_on(self.serial_port):
            #     power_on(self.serial_port)
            #     if check_power_on(self.serial_port):
            #         logging.info('OK')
            #     else:
            #         raise Exception('Device down')
            # else:
            #     logging.info('OK')
            logging.info('initial setiings..')
            if load_initial_settings(self.serial_port):
                logging.info('OK')
            else:
                raise Exception('Init settings failed')
            self.get_sm_size()
            self.set_status('sleep')
        except Exception as e:
            for frame in traceback.extract_tb(sys.exc_info()[2]):
                fname,lineno,fn,text = frame
                print("Error in %s on line %d" % (fname, lineno))
            logging.error('%s %s'%(sys.exc_info()[0], sys.exc_info()[1]))
            self.set_status('crashed')
    def send_sms(self):
        try:
            logging.debug
            if not send_command(self.serial_port, b'AT+CMGS="' + self.sms.recipient + b'"\r', b'>'):
                raise Exception('message was not sended')
            if not send_command(self.serial_port,self.sms.content +bytes([26])):
                raise Exception('message was not sended')
            logging.debug('sended sucessful')
            self.set_sms(None)
            self.set_status('sleep')
        except Exception as e:
            for frame in traceback.extract_tb(sys.exc_info()[2]):
                fname,lineno,fn,text = frame
                print("Error in %s on line %d" % (fname, lineno))
            logging.error('%s %s'%(sys.exc_info()[0], sys.exc_info()[1]))
            self.set_status('crashed')
    # def check_sms(self):
    #     try:
    #         answer=send_command(self.serial_port,b'AT+CMGD=?', None)
            
    #         logging.debug('recieved %d messages')
    #         logging.debug('status: sleep')
    #         self.check_timestamp=time.time()
    #         self.status='sleep'
    #     except Exception as e:
    #         for frame in traceback.extract_tb(sys.exc_info()[2]):
    #             fname,lineno,fn,text = frame
    #             print("Error in %s on line %d" % (fname, lineno))
    #         logging.error('%s %s'%(sys.exc_info()[0], sys.exc_info()[1]))
    #         logging.debug('status: crashed')
    #         self.status='crashed'

    def read_sms(self):
        try:
            sm=self.check_sm()
            if not len(sm)==0:
                global recieved_sms_queue
                #if not send_command(self.serial_port, b'AT+CSCS="IRA"\r'):
                #    raise Exception('Setting device mode to IRA failed')
            logging.debug('recieved %d new messages'%len(sm))
            for i in sm:
                end_of_command=i+b'\r'
                command=b'AT+CMGR='+end_of_command
                answer=send_command(self.serial_port,command,None)
                data=answer.split(b',')
                recipient=data[1].replace(b'"',b'')
                content=data[4].split(b'\r\n')[1]
                content=binascii.unhexlify(content)
                sms=SMS(recipient=recipient, content=content)
                recieved_sms_queue.put(sms)
                command=b'AT+CMGD='+end_of_command
                send_command(self.serial_port,command)
                logging.info('recieved message %s'%sms)
            #if not send_command(self.serial_port, b'AT+CSCS="IRA"\r'):
            #    raise Exception('Setting device mode to IRA failed')
            self.set_status('sleep')
            self.check_timestamp=time.time()
        except Exception as e:
            for frame in traceback.extract_tb(sys.exc_info()[2]):
                fname,lineno,fn,text = frame
                print("Error in %s on line %d" % (fname, lineno))
            logging.error('%s %s'%(sys.exc_info()[0], sys.exc_info()[1]))
            self.set_status('crashed')
    def get_sm_size(self):
        command=b'AT+CPMS?\r'
        answer=send_command(self.serial_port,command, None)
        sm_size=int(answer.split(b'"SM"')[1].split(b',')[1])
        for i in range(sm_size):
               self.sm.append(None)
        return 0
    def check_sm(self):
        command=b'AT+CMGD=?\r'
        template=b'\n+CMGD: '
        answer=send_command(self.serial_port,command, None)
        answer=answer[1+answer.find(b'(',answer.find(template)):answer.find(b')',answer.find(template))]
        sm=answer.split(b',')
        if sm[0]==b'':
            sm=[]
        logging.debug('SM %s, len(sm) %d'%(sm,len(sm)))
        return sm
class SMS():
    def __init__(self, *args, **kwargs):
        self.byte_message=[]
        if 'recipient' in kwargs and 'content' in kwargs:
            self.recipient=write_hex(kwargs.get('recipient'))
            self.content=write_hex(kwargs.get('content'))
        elif args[0][:3]==b'sms':
            self.recipient=write_hex(args[0][3:15])
            self.content=write_hex(args[0][15:])
        else:
            logging.debug('can not construct message from %s'%args[0])
        #self.to_bytes()
        logging.debug('message constructed: %s'%self)
    def __repr__(self):
        return '%s %s'%(self.recipient,self.content)
    def __str__(self):
        return 'recipient: %s\n content: %s'%(self.recipient,self.content)    
    def to_base(self):
        data=binascii.unhexlify(self.content)
        length=data[2]
        proto=[data[0],data[1],data[2],data[3:7],data[7:11],data[11:3+length-2],data[3+length-2:3+length]]
        logging.debug(proto)
        if not proto[0]==35:
            raise Exception('Proto error')
        if not proto[1]==1:
            raise Exception('Proto error')
        sender=struct.unpack('I',proto[3])[0]
        reciver=struct.unpack('I',proto[4])[0]
        body=[proto[5][0],proto[5][1:]]
        logging.debug(body)
        mes_id=body[0]
        mes_content=body[1]
        if mes_id==1:
            data=[mes_content[:8],mes_content[8:14],mes_content[14:20],mes_content[20:22],mes_content[22:24],mes_content[24],mes_content[24:36]]
            logging.debug(data)
            time=datetime.datetime.fromtimestamp(struct.unpack('q',data[0])[0])
            lon=from_our_format2float(data[1])
            lat=from_our_format2float(data[2])
            #lon=struct.unpack('d',data[1])[0]
            #lat=struct.unpack('d',data[2])[0]
            brightness=struct.unpack('H',data[3])[0]
            bat_charge=struct.unpack('H',data[4])[0]
            inclination=data[5]
            alarm_reg=data[6]
            logging.debug('sender %s time %s lat %s lon %s brightness %s bat_charge %s inclination %s alarm_reg %s'%(sender,time,lat,lon,brightness,bat_charge,inclination,alarm_reg))
            logging.debug(fl_models.NsControlBouymessage(blink_mode=1,bouy=sender,time=time,lat=lat,lon=lon,brightness=brightness,charge=bat_charge,inclination=inclination).save()==1)
        else:
            logging.debug('message id not 1')
class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024).strip()
        logging.debug('bytes recieved: %s'%self.data)
        sms=SMS(self.data)
        global send_sms_queue
        send_sms_queue.put(sms)
def send_command(serial_port, command_b, answer=msg_ok, timeout=timeout):
    #serial_port.flushInput()
    serial_port.read(serial_port.inWaiting())
    serial_port.write(command_b)
    return wait_for(serial_port, answer, timeout)
def wait_for(serial_port, template, timeout=timeout):
    if template==None:
        template=msg_ok
        return_answer=True
    else:
        template=template
        return_answer=False
    answer=(b'')
    timestamp=time.time()
    while time.time()-timestamp<timeout and not template in answer and not msg_error in answer:
        answer+=serial_port.read(serial_port.inWaiting())
        time.sleep(0.1)
    logging.debug('Recieved from: *** %s ***: %s'%(serial_port.port,answer))
    if return_answer:
        return answer
    else:
        return template in answer
def check_power_on(serial_port):
    return send_command(serial_port, b'AT\r')
def power_on(serial_port):
    serial_port.write(b'+++')
def load_initial_settings(serial_port):
    if not send_command(serial_port, b'ATZ\r'):
        return False 
    if not send_command(serial_port, b'AT+CSMP=17,167,0,4\r'):
        return False
    if not send_command(serial_port, b'AT+CSCS="HEX"\r'):
        return False
    return send_command(serial_port, b'AT+CMGF=1\r')

# STATE MACHINE
# +STATES
def idle():
    logging.info('initialization..')
    global state
    global tcp_serv_thread
    global devices
    threading.Thread(target=fl_models.database.connect).start()
    for port in serial_ports:
        serial_port=serial.Serial(port,115200*256)
        dev=Device(serial_port)
        devices.append(dev)
        logging.debug('starting init thread')
        dev.set_status('running')
        thread=threading.Thread(target=dev.initiate)
        thread.setDaemon(True)
        thread.start()
        logging.debug('work is done')
    logging.info('TCP server')
    tcp_serv=socketserver.TCPServer(tcp_serv_addr, MyTCPHandler)
    tcp_serv.allow_reuse_address=True
    tcp_serv_thread=threading.Thread(target=tcp_serv.serve_forever)
    tcp_serv_thread.daemon=True
    tcp_serv_thread.start()
    logging.info('OK')
    state='wait'
    while not state=='shutdown':
        logging.debug('ready to serve')
        manage_devices()
        time.sleep(period)
def shutdown():
    logging.info('shutting down')
    exit()
options={
    'idle':idle,
#    'wait':wait,
    'shutdown':shutdown,
}
#-STATES
def main():
    logging.debug('Current state is: %s'%state)
    options[state]()
if __name__ == "__main__":
    main()


