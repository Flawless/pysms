#!/usr/bin/env python
#import serial
import time
import socketserver
import queue
import threading
import logging
import sys
import datetime
# SETTINGS
tcp_serv_addr=('localhost', 9999)
#SER_PORT='/dev/ttyACM0'
#BAUDRATE='19200'
msg_ok='OK\r\n'
period=60
timeout=30
# INIT
logging.basicConfig(format = u'%(levelname)-8s [%(asctime)s] %(message)s', level = logging.DEBUG, filename = u'/var/log/pysms.log')
state='idle'
#ser=serial.Serial(SER_PORT, BAUDRATE, timeout=5)
timestamp=time.time()
queue=queue.Queue()
tcp_serv_thread=threading.Thread()
NUMBER_THREADS=1
class SMS():
    def __init__(self, *args, **kwargs):
        if 'recipient' in kwargs and 'content' in kwargs:
            self.recipient=kwargs.get('recipient')
            self.content=kwargs.get('content').encode('utf-8')
        else:
            raise Exception
    def __init__(self, recipient, content):
        self.recipient=recipient
        self.content=content.encode('utf-8')
    def __repr__(self):
        return '%s %s'%(self.recipient.decode('utf-8'),self.content.decode('utf-8'))
    def send(self):
        if not send_command('AT+CMGS="' + self.recipient + '"\r', '>'):
            return False
        if not send_command(self.content + b'\r', '>'):
            return False
        return send_command(bytes([26]))
def tcp_data_parse(data):
    parsed_data=data
    return parsed_data
def reinit():
    state='idle'
class error_counter():
    def __init__(self, maximum, reset):
        self.count=0
        self.maximum=maximum
    def increase(self, step=1):
        self.count+=step
        if self.count>=self.maximum:
            self.reset()
            self.count=0
sms_error_counter=error_counter(5,reinit)
class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024).strip()
        logger.debug(self.data)
class SmsSender(threading.Thread):
    def __init__(self):
        super(SmsSender,self).__init__()
        self.setDaemon(True)
        self.queue=queue
    def run(self):
        while True:
            try:
                start=datetime.datetime.now().strftime('%H:%M:%S')
                sms=self.queue.get(block=False)
                if sms.send():
                    logging.info('%s %s %s'% (u'Message',sms,u'sended.'))
                else:
                    logging.warning('%s %s %s'% (u'Message',sms,u'not sended. Service will try to resend it again later.'))
                    raise Exception('Message not sended')
                self.queue.task_done()
            except queue.Empty:
                logger.error('%s get Queue.EMPTY exception\r\n'%self.getName())
                break
            except Exception as e:
                logger.error('%s get %s exception\r\n'%(self.getName(),e))
                self.queue.task_done()
                sms_error_counter.increase()
                self.queue.put(sms)
def send_command(command_str, answer=msg_ok, timeout=timeout):
    global ser
    ser.flushInput()
    ser.write(command_str.encode())
    return wait_for(answer, timeout)
def wait_for(template, timeout=timeout):
    global ser
    template=template.encode()
    answer = (b'')
    timestamp=time.time()
    while time.time()-timestamp<timeout and not template in answer:
        answer+=ser.read(ser.inWaiting())
        time.sleep(0.1)
    print(answer)
    return template in answer
def check_power_on():
    return send_command('AT\r')
def power_on():
    ser.write(b'+++')
def load_initial_settings():
    if not send_command('ATZ\r'):
        return False 
    if not send_command('AT+CSMP=17,167,0,0\r'):
        return False
    return send_command('AT+CMGF=1\r')
# STATE MACHINE
# +STATES
def idle():
    print('initialization..')
    global ser
    global state
    global tcp_serv_thread
    logging.info('TCP server')
    tcp_serv=socketserver.TCPServer(tcp_serv_addr, MyTCPHandler)
    tcp_serv_thread=threading.Thread(target=tcp_serv.serve_forever)
    # try:
    tcp_serv_thread.start()
    logging.info('OK')
    #except:
    #    logging.error(sys.exc_info()[0])
    # print('serial..')
    # if not ser.isOpen():
    #     ser=ser.open()
    #     if ser.isOpen(): 
    #         print('OK')
    #     else:
    #         print('FAIL')
    #         return
    # else:
    #     print('OK')
    # print('power..')
    # if not check_power_on():
    #     power_on()
    #     if check_power_on():
    #         print('OK')
    #     else:
    #         print('FAIL')
    #         return
    # else:
    #     print('OK')
    # print('initial setiings..')
    # if load_initial_settings():
    #     print('OK')
    # else:
    #     print('FAIL')
    #     return
    state='wait'
def wait():
    print('Ready to serve!')
    threads=[]
    for i in range(NUMBER_THREADS):
        threads.append(SmsSender())
        threads[-1].start()
    queue.join()
    time.sleep(period)
options={
    'idle':idle,
    'wait':wait,
}
#-STATES
while True:
    options[state]()
