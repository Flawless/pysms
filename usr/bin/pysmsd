#!/usr/bin/env python
#import serial
import time
import socketserver
import queue
import threading
import logging
import sys
import datetime
import signal
import ast
# SETTINGS
tcp_serv_addr=('localhost', 25111)
#SER_PORT='/dev/ttyACM0'
#BAUDRATE='19200'
shutdown_flag=False
msg_ok='OK\r\n'
period=60
timeout=30
# INIT
logging.basicConfig(format = u'%(levelname)-8s [%(asctime)s] %(message)s', level = logging.DEBUG, filename = '/var/log/pysms.log')
state='idle'
#ser=serial.Serial(SER_PORT, BAUDRATE, timeout=5)
timestamp=time.time()
sms_queue=queue.Queue()
tcp_serv_thread=threading.Thread()
NUMBER_THREADS=1
def myexcepthook(exctype, value, traceback):
    if exctype == KeyboardInterrupt:
        logging.info('Terminated by user')
        global shutdown_flag
        shutdown_flag=True
    else:
        sys.__excepthook__(exctype, value, traceback)
sys.excepthook = myexcepthook
def signal_term_handler(signal, frame):
    global shutdown_flag
    logging.info('recieved sigterm')
    shutdown_flag=True
signal.signal(signal.SIGTERM, signal_term_handler)

class SMS():
    def __init__(self, *args, **kwargs):
        if 'recipient' in kwargs and 'content' in kwargs:
            self.recipient=kwargs.get('recipient')
            self.content=kwargs.get('content').encode('utf-8')
        else:
            self.recipient=args[0][:12]
            self.content=args[0][12:]
        logging.debug('message constructed: %s'%self)
    def __repr__(self):
        return '%s %s'%(self.recipient.decode('utf-8'),self.content.decode('utf-8'))
    def __str__(self):
        return 'recipient: %s\n content: %s'%(self.recipient.decode('utf-8'),self.content.decode('utf-8'))    
    def send(self):
        if not send_command('AT+CMGS="' + self.recipient + '"\r', '>'):
            return False
        if not send_command(self.content + b'\r', '>'):
            return False
        return send_command(bytes([26]))
def tcp_data_parse(data):
    parsed_data=data
    return parsed_data
def reinit():
    state='idle'
class error_counter():
    def __init__(self, maximum, reset):
        self.count=0
        self.maximum=maximum
    def increase(self, step=1):
        self.count+=step
        if self.count>=self.maximum:
            self.reset()
            self.count=0
sms_error_counter=error_counter(5,reinit)
class MyTCPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024).strip()
        logging.debug('bytes recieved: %s'%self.data)
        sms=SMS(self.data)
class SmsSender(threading.Thread):
    def __init__(self):
        super(SmsSender,self).__init__()
        self.setDaemon(True)
        self.sms_queue=sms_queue
    def run(self):
        while True:
            try:
                start=datetime.datetime.now().strftime('%H:%M:%S')
                sms=self.sms_queue.get(block=False)
                if sms.send():
                    logging.info('%s %s %s'% ('Message',sms,'sended.'))
                else:
                    logging.warning('%s %s %s'% ('Message',sms,'not sended. Service will try to resend it again later.'))
                    raise Exception('Message not sended')
                self.sms_queue.task_done()
            except queue.Empty:
                logging.error('%s get Queue.EMPTY exception\r\n'%self.getName())
                break
            except Exception as e:
                logging.error('%s get %s exception\r\n'%(self.getName(),e))
                self.sms_queue.task_done()
                sms_error_counter.increase()
                self.sms_queue.put(sms)
def send_command(command_str, answer=msg_ok, timeout=timeout):
    global ser
    ser.flushInput()
    ser.write(command_str.encode())
    return wait_for(answer, timeout)
def wait_for(template, timeout=timeout):
    global ser
    template=template.encode()
    answer = (b'')
    timestamp=time.time()
    while time.time()-timestamp<timeout and not template in answer:
        answer+=ser.read(ser.inWaiting())
        time.sleep(0.1)
    print(answer)
    return template in answer
def check_power_on():
    return send_command('AT\r')
def power_on():
    ser.write(b'+++')
def load_initial_settings():
    if not send_command('ATZ\r'):
        return False 
    if not send_command('AT+CSMP=17,167,0,0\r'):
        return False
    return send_command('AT+CMGF=1\r')
# STATE MACHINE
# +STATES
def idle():
    print('initialization..')
    global ser
    global state
    global tcp_serv_thread
    logging.info('TCP server')
    tcp_serv=socketserver.TCPServer(tcp_serv_addr, MyTCPHandler)
    tcp_serv.allow_reuse_address=True
    tcp_serv_thread=threading.Thread(target=tcp_serv.serve_forever)
    tcp_serv_thread.daemon=True
    tcp_serv_thread.start()
    logging.info('OK')
    #except:
    #    logging.error(sys.exc_info()[0])
    # print('serial..')
    # if not ser.isOpen():
    #     ser=ser.open()
    #     if ser.isOpen(): 
    #         print('OK')
    #     else:
    #         print('FAIL')
    #         return
    # else:
    #     print('OK')
    # print('power..')
    # if not check_power_on():
    #     power_on()
    #     if check_power_on():
    #         print('OK')
    #     else:
    #         print('FAIL')
    #         return
    # else:
    #     print('OK')
    # print('initial setiings..')
    # if load_initial_settings():
    #     print('OK')
    # else:
    #     print('FAIL')
    #     return
    state='wait'
def wait():
    logging.debug('Ready to serve!')
    threads=[]
    for i in range(NUMBER_THREADS):
        threads.append(SmsSender())
        threads[-1].start()
    sms_queue.join()
    time.sleep(period)
options={
    'idle':idle,
    'wait':wait,
}
#-STATES
while not shutdown_flag:
    options[state]()
